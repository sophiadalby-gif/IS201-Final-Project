<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Whimsical Pink Snake</title>

  <!-- Montserrat for thin, modern letters -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#e9f5ff;        /* light blue */
      --panel:#ffffff;     /* white panel */
      --accent:#0d2e57;    /* dark blue title */
      --text:#264057;      /* darker text */
      --border:#bcd9f3;
      --snake:#ff7fbf;     /* pink snake */
    }

    html,body{height:100%;margin:0;font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{
      background: linear-gradient(180deg,var(--bg),#f6fbff);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
      color:var(--text);
    }

    .card{
      width:min(980px,94vw);
      background:var(--panel);
      border-radius:18px;
      padding:20px;
      box-shadow:0 8px 30px rgba(14,30,50,0.08);
      border:2px solid var(--border);
      text-align:center;
      position:relative;
    }

    h1{
      margin:6px 0 12px;
      color:var(--accent);
      font-weight:300;
      letter-spacing:1px;
      font-size:28px;
    }

    p.lead{
      margin:0 0 16px;
      color:var(--text);
      font-weight:300;
    }

    .game-row{
      display:flex;
      gap:20px;
      align-items:flex-start;
      justify-content:center;
      flex-wrap:wrap;
    }

    /* canvas box */
    .play-area{
      background:linear-gradient(180deg,#f9fdff,#eef8ff);
      border-radius:12px;
      padding:12px;
      border:1px solid var(--border);
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    canvas{
      background:transparent;
      display:block;
      border-radius:8px;
      box-shadow: inset 0 2px 10px rgba(10,30,60,0.02);
      image-rendering: pixelated;
    }

    .sidebar{
      min-width:220px;
      max-width:260px;
      text-align:left;
      font-weight:300;
    }

    .panel{
      background:linear-gradient(180deg,#ffffff,#fbfeff);
      border-radius:10px;
      border:1px dashed var(--border);
      padding:12px;
      margin-bottom:12px;
    }

    .score{
      font-size:20px;
      font-weight:400;
      color:var(--accent);
      text-align:center;
      margin-bottom:8px;
    }

    .small{
      font-size:13px;
      color:var(--text);
      margin:6px 0;
    }

    .controls{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      justify-content:center;
      margin-top:8px;
    }

    .btn{
      background:transparent;
      border:1px solid var(--border);
      padding:8px 10px;
      border-radius:8px;
      font-weight:400;
      cursor:pointer;
      color:var(--text);
      font-size:13px;
    }

    .btn:hover{transform:translateY(-1px)}
    .muted{opacity:0.85}

    .footer-note{
      margin-top:14px;
      font-size:12px;
      color:rgba(38,64,87,0.7);
      text-align:center;
    }

    /* little snowflake decorations on border */
    .snow-deco{
      position:absolute;
      width:28px;
      opacity:0.55;
    }
    .snow-deco.s1{left:12px;top:8px}
    .snow-deco.s2{right:10px;top:12px}
    .snow-deco.s3{left:8px;bottom:12px}
    .snow-deco.s4{right:12px;bottom:8px}

    @media (max-width:720px){
      .game-row{flex-direction:column;align-items:center;}
      .sidebar{width:94%}
    }
  </style>
</head>
<body>
  <div class="card" role="application" aria-label="Snake game">
    <img class="snow-deco s1" src="https://cdn-icons-png.flaticon.com/512/4151/4151022.png" alt="" />
    <img class="snow-deco s2" src="https://cdn-icons-png.flaticon.com/512/4151/4151022.png" alt="" />
    <img class="snow-deco s3" src="https://cdn-icons-png.flaticon.com/512/4151/4151022.png" alt="" />
    <img class="snow-deco s4" src="https://cdn-icons-png.flaticon.com/512/4151/4151022.png" alt="" />

    <h1>Whimsical Holiday Snake</h1>
    <p class="lead">Guide the pink snake to tasty fruits. A new fruit appears every 4 seconds if you don't get it ‚Äî catch it quicker for a higher score!</p>

    <div class="game-row">
      <div class="play-area" aria-hidden="false">
        <!-- canvas -->
        <canvas id="game" width="480" height="480"></canvas>
        <div style="display:flex;gap:12px;align-items:center;margin-top:10px;">
          <div class="score" id="score">Score: 0</div>
          <div class="small muted" id="fruitTimer">Fruit moves in: 4s</div>
        </div>
        <div class="footer-note">Use Arrow keys or W/A/S/D ‚Ä¢ Don't run into the walls or yourself</div>
      </div>

      <div class="sidebar">
        <div class="panel">
          <div style="font-size:14px;font-weight:400;color:var(--accent);margin-bottom:6px">Fruits to catch</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <!-- show fruit icons and names -->
            <div class="small">üçé Apple</div>
            <div class="small">üçå Banana</div>
            <div class="small">üçí Cherry</div>
            <div class="small">üçá Grape</div>
            <div class="small">üçä Orange</div>
            <div class="small">üçê Pear</div>
          </div>
        </div>

        <div class="panel">
          <div style="font-size:14px;font-weight:400;color:var(--accent);margin-bottom:6px">Tips</div>
          <div class="small">Plan ahead ‚Äî fruit moves every 4 seconds if not eaten.</div>
          <div class="small">Losing occurs when you hit walls or yourself. Restart to play again.</div>
        </div>

        <div style="display:flex;gap:8px">
          <button id="startBtn" class="btn">Start</button>
          <button id="pauseBtn" class="btn">Pause</button>
          <button id="resetBtn" class="btn">Reset</button>
        </div>
        <div style="height:10px"></div>
        <div class="panel">
          <div style="font-size:13px;font-weight:400;color:var(--accent);margin-bottom:6px">How fruit relocation works</div>
          <div class="small">Every 4 seconds the current fruit teleports to a new random empty tile (timer resets when eaten).</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   SIMPLE SNAKE GAME (single file)
   - Grid-based canvas
   - Pink snake
   - 6 fruits which are emoji icons
   - Fruit relocates every 4 seconds if not eaten
   --------------------------- */

(() => {
  // Config
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const fruitTimerEl = document.getElementById('fruitTimer');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  const TILE_COUNT = 16;                  // 16x16 grid
  const SIZE = canvas.width / TILE_COUNT; // tile size
  const SNAKE_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--snake').trim() || '#ff7fbf';
  const FRUIT_MOVE_INTERVAL = 4000;       // ms (4 seconds)
  const GAME_SPEED = 10;                  // frames per second (snake ticks)

  const fruits = [
    {emoji: 'üçé', name: 'Apple'},
    {emoji: 'üçå', name: 'Banana'},
    {emoji: 'üçí', name: 'Cherry'},
    {emoji: 'üçá', name: 'Grape'},
    {emoji: 'üçä', name: 'Orange'},
    {emoji: 'üçê', name: 'Pear'},
  ];

  // Game state
  let snake = [{x:8,y:8}]; // head at center
  let dir = {x:0,y:0};
  let nextDir = {x:0,y:0};
  let fruit = {x:5, y:5, type:0};
  let score = 0;
  let lastFrameTime = 0;
  let tickInterval = 1000 / GAME_SPEED;
  let running = false;
  let gameOver = false;

  // Fruit movement timer
  let fruitTimer = FRUIT_MOVE_INTERVAL;
  let fruitIntervalId = null;
  let fruitCountdownInterval = null;

  // Utilities
  function randTile(){
    return Math.floor(Math.random()*TILE_COUNT);
  }

  function placeRandomFruit(){
    // find empty tile not occupied by snake
    let x,y,tries=0,occupied;
    do{
      x = randTile();
      y = randTile();
      occupied = snake.some(s => s.x === x && s.y === y);
      tries++;
    } while(occupied && tries < 200);
    fruit.x = x; fruit.y = y;
    // randomly choose which fruit type
    fruit.type = Math.floor(Math.random() * fruits.length);
    resetFruitTimer();
  }

  function resetGame(){
    snake = [{x:8,y:8}];
    dir = {x:0,y:0};
    nextDir = {x:0,y:0};
    score = 0;
    scoreEl.textContent = 'Score: 0';
    gameOver = false;
    placeRandomFruit();
    running = false;
    clearIntervals();
    updateFruitTimerDisplay();
  }

  function clearIntervals(){
    if(fruitIntervalId) { clearInterval(fruitIntervalId); fruitIntervalId = null; }
    if(fruitCountdownInterval) { clearInterval(fruitCountdownInterval); fruitCountdownInterval = null; }
  }

  function resetFruitTimer(){
    fruitTimer = FRUIT_MOVE_INTERVAL;
    // clear earlier intervals and re-start
    if(fruitIntervalId) clearInterval(fruitIntervalId);
    if(fruitCountdownInterval) clearInterval(fruitCountdownInterval);

    // When interval fires, move fruit
    fruitIntervalId = setInterval(() => {
      // Only move fruit if game is running (so it doesn't move while paused)
      if(!running || gameOver) return;
      placeRandomFruit(); // picks new spot and resets timer
    }, FRUIT_MOVE_INTERVAL);

    // Countdown display update every 200ms
    fruitCountdownInterval = setInterval(() => {
      if(!running || gameOver) return;
      fruitTimer -= 200;
      if(fruitTimer < 0) fruitTimer = 0;
      updateFruitTimerDisplay();
    }, 200);

    updateFruitTimerDisplay();
  }

  function updateFruitTimerDisplay(){
    const secs = Math.ceil(fruitTimer / 1000);
    fruitTimerEl.textContent = `Fruit moves in: ${secs}s`;
  }

  // Input handling
  const keyMap = {
    'ArrowUp': {x:0,y:-1},
    'ArrowDown': {x:0,y:1},
    'ArrowLeft': {x:-1,y:0},
    'ArrowRight': {x:1,y:0},
    'w': {x:0,y:-1}, 'W':{x:0,y:-1},
    's': {x:0,y:1},  'S':{x:0,y:1},
    'a': {x:-1,y:0}, 'A':{x:-1,y:0},
    'd': {x:1,y:0},  'D':{x:1,y:0},
  };

  window.addEventListener('keydown', e => {
    if(gameOver && e.key === 'Enter'){ startGame(); return; }
    if(!keyMap[e.key]) return;
    const nd = keyMap[e.key];
    // Prevent reversing directly
    if((nd.x === -dir.x && nd.y === -dir.y)) return;
    nextDir = nd;
    // start the game on first movement
    if(!running && !gameOver){
      startGame();
    }
  });

  // Game control buttons
  startBtn.addEventListener('click', startGame);
  pauseBtn.addEventListener('click', togglePause);
  resetBtn.addEventListener('click', () => { resetGame(); draw(); });

  function startGame(){
    if(gameOver) { resetGame(); }
    running = true;
    resetFruitTimer();
  }

  function togglePause(){
    running = !running;
    if(!running){
      // paused
      clearIntervals();
      fruitTimerEl.textContent = 'Paused';
    } else {
      resetFruitTimer();
    }
  }

  function endGame(){
    running = false;
    gameOver = true;
    clearIntervals();
    fruitTimerEl.textContent = 'Game Over - press Start to play again';
    // flash message on canvas
    draw();
    ctx.fillStyle = 'rgba(13,46,87,0.85)';
    ctx.fillRect(0, canvas.height/2 - 36, canvas.width, 72);
    ctx.fillStyle = '#fff';
    ctx.font = '22px Montserrat, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 2);
    ctx.font = '14px Montserrat, sans-serif';
    ctx.fillText('Press Start to play again', canvas.width/2, canvas.height/2 + 20);
  }

  // Game tick: move snake per tick
  function tick(){
    // apply nextDir if provided
    if(nextDir.x !== 0 || nextDir.y !== 0){
      dir = nextDir;
      nextDir = {x:0,y:0};
    }
    // if dir is zero, don't move
    if(dir.x === 0 && dir.y === 0) return;

    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

    // collision with walls -> game over
    if(head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT){
      endGame();
      return;
    }

    // collision with self
    if(snake.some(seg => seg.x === head.x && seg.y === head.y)){
      endGame();
      return;
    }

    // add new head
    snake.unshift(head);

    // check fruit
    if(head.x === fruit.x && head.y === fruit.y){
      // ate fruit
      score += 1;
      scoreEl.textContent = 'Score: ' + score;
      // place new fruit and reset timer
      placeRandomFruit();
    } else {
      // remove tail
      snake.pop();
    }
  }

  // Draw grid, snake, fruit
  function draw(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw subtle grid background
    ctx.fillStyle = '#f6fbff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Draw tile grid faint lines
    ctx.strokeStyle = 'rgba(38,64,87,0.04)';
    for(let i=0;i<=TILE_COUNT;i++){
      const pos = i * SIZE;
      ctx.beginPath(); ctx.moveTo(pos,0); ctx.lineTo(pos,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,pos); ctx.lineTo(canvas.width,pos); ctx.stroke();
    }

    // Draw fruit as emoji
    const fr = fruits[fruit.type];
    ctx.font = `${SIZE-4}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(fr.emoji, fruit.x * SIZE + SIZE/2, fruit.y * SIZE + SIZE/2);

    // Draw snake segments
    for(let i=0;i<snake.length;i++){
      const seg = snake[i];
      const x = seg.x * SIZE;
      const y = seg.y * SIZE;
      // head a bit brighter
      ctx.fillStyle = SNAKE_COLOR;
      ctx.fillRect(x+2, y+2, SIZE-4, SIZE-4);
      // add subtle inner highlight for head
      if(i === 0){
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(x+4,y+4,SIZE-8,SIZE-8);
      }
    }
  }

  // Game loop using requestAnimationFrame for smooth draw, but update tick at fixed rate
  function frame(ts){
    if(!lastFrameTime) lastFrameTime = ts;
    const elapsed = ts - lastFrameTime;

    if(elapsed > tickInterval){
      lastFrameTime = ts - (elapsed % tickInterval);
      if(running && !gameOver){
        tick();
      }
      draw();
    }

    requestAnimationFrame(frame);
  }

  // Initialize
  resetGame();
  draw();
  requestAnimationFrame(frame);

  // If the fruit interval is running, decrease its display with a real timer as well
  // (Handled in resetFruitTimer)

  // Ensure fruit timer starts only when the game is running. placeRandomFruit also calls resetFruitTimer
  // but when we reset game we clear intervals.

  // Make sure canvas scales nicely on high-DPI screens
  function resizeForDisplay() {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth || canvas.width;
    const h = canvas.clientHeight || canvas.height;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.scale(dpr, dpr);
    // Recompute SIZE to keep grid consistent
    // We'll keep Tile count fixed but visually adapt tile size
    // Reset font smoothing
  }

  // Set initial style size so SIZE is consistent visually
  function adaptCanvasSize(){
    // keep canvas square based on client width, but ensure integer tile size
    const maxPx = Math.min(480, Math.floor(window.innerWidth * 0.55));
    canvas.style.width = maxPx + 'px';
    canvas.style.height = maxPx + 'px';
    // update underlying width/height to physical pixels and scale context
    const dpr = window.devicePixelRatio || 1;
    canvas.width = maxPx * dpr;
    canvas.height = maxPx * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0); // reset scale
  }

  // initial adapt
  adaptCanvasSize();
  window.addEventListener('resize', () => {
    adaptCanvasSize();
    draw();
  });

  // Start the fruit timer in paused state only when the game is started.
  // If player clicks Start, resetFruitTimer gets invoked.

})();
</script>
</body>
</html>
